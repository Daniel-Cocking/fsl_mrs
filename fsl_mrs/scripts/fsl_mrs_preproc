#!/usr/bin/env python

# fsl_mrs_preproc - wrapper script for single voxel MRS preprocessing
#
# Author: Saad Jbabdi <saad@fmrib.ox.ac.uk>
#         William Clarke <william.clarke@ndcn.ox.ac.uk>
#
# Copyright (C) 2019 University of Oxford 
# SHBASECOPYRIGHT

# Quick imports
#import argparse
import configargparse

from fsl_mrs import __version__
from fsl_mrs.utils.splash import splash
from fsl_mrs.utils import mrs_io
import numpy as np
import os

# NOTE!!!! THERE ARE MORE IMPORTS IN THE CODE BELOW (AFTER ARGPARSING)


def main():
    # Parse command-line arguments
    p = configargparse.ArgParser(add_config_file_help=False,description="FSL Magnetic Resonance Spectroscopy - Complete non-edited SVS Preprocessing")

    p.add_argument('-v','--version', action='version', version=__version__)

    required     = p.add_argument_group('required arguments')
    optional     = p.add_argument_group('additional options')


    # REQUIRED ARGUMENTS
    required.add_argument('--data',
                          required=True,type=str,nargs='+',metavar='<str>',
                          help='list of input files')
    required.add_argument('--reference',
                          required=True,type=str,nargs='+',metavar='<str>',
                          help='list of non-water suppressed files')    
    required.add_argument('--output',
                          required=True,type=str,metavar='<str>',
                          help='output folder')

    # ADDITONAL OPTIONAL ARGUMENTS
    optional.add_argument('--quant',type=str,nargs='+',default=None,metavar='<str>',
                          help='Water reference data for quantification (Optional).')
    optional.add_argument('--ecc',type=str,nargs='+',default=None,metavar='<str>',
                          help='Water reference data for eddy current correction (Optional).')
    # option to not average, this will toggle the average property to False
    optional.add_argument('--noaverage',action="store_false",dest='average',
                          help='Do not average repetitions.')
    optional.add_argument('--hlsvd',action="store_true",
                          help='Apply HLSVD for residual water removal.')
    optional.add_argument('--leftshift',type=int,metavar='POINTS',
                          help='Remove points at the start of the fid.')                      
    optional.add_argument('--t1',type=str,default=None,metavar='IMAGE',
                          help='structural image (for report)')
    optional.add_argument('--verbose',action="store_true",
                          help='spit out verbose info')
    optional.add_argument('--conjugate',action="store_true",
                          help='apply conjugate to FID')
    optional.add_argument('--overwrite',action="store_true",
                          help='overwrite existing output folder')
    optional.add('--config', required=False, is_config_file=True, help='configuration file')

    # Parse command-line arguments
    args = p.parse_args()
    
    # Output kickass splash screen
    if args.verbose:
        splash(logo='mrs')
    

    # ######################################################
    # DO THE IMPORTS AFTER PARSING TO SPEED UP HELP DISPLAY
    import time, os, sys, shutil, warnings
    from fsl_mrs.core import MRS
    from fsl_mrs.utils import report
    from fsl_mrs.utils import preproc
    from fsl_mrs.utils import plotting
    from fsl_mrs.utils import misc
    import datetime
    import copy
    # ######################################################

    
    
    # Check if output folder exists
    overwrite = args.overwrite
    if os.path.exists(args.output):
        if not overwrite:
            print("Folder '{}' exists. Are you sure you want to delete it? [Y,N]".format(args.output))
            response = input()
            overwrite = response.upper() == "Y"
        if not overwrite:
            print('Early stopping...')
            exit()
        else:
            shutil.rmtree(args.output)
            os.mkdir(args.output)
    else:
        os.mkdir(args.output)



    # Save chosen arguments
    with open(os.path.join(args.output,"options.txt"),"w") as f:
        f.write(str(args))
        f.write("\n--------\n")
        f.write(p.format_values())
        


    #######  Do the work #######
    if args.verbose:
        print('Load the data....')
    
    # Read all data
    # Suppressed data
    FIDlist,hdr,shape,datatype = readData(args.data,args.conjugate)
    if args.verbose:
        print('.... Found {} repeats of the data FIDs with shape {} each.\n\n'.format(len(FIDlist),shape))
    # Reference data
    Reflist,refhdr,refshape,_ = readData(args.reference,args.conjugate)
    if args.verbose:
        print('.... Found {} repeats of the reference FIDs with shape {} each.\n\n'.format(len(Reflist),refshape))

    if args.quant is not None:
        # Separate quant data
        quantlist,quanthdr,quantshape,_ = readData(args.quant,args.conjugate)
        if args.verbose:
            print('.... Found {} repeats of the quant FIDs with shape {} each.\n\n'.format(len(quantlist),quantshape))

    if args.ecc is not None:
        # Separate ecc data
        ecclist,ecchdr,eccshape,_ = readData(args.ecc,args.conjugate)
        if args.verbose:
            print('.... Found {} repeats of the ecc FIDs with shape {} each.\n\n'.format(len(ecclist),eccshape))


    # Determine if coils have been combined already
    if args.verbose:
        print('.... Determine if coil combination is needed')
    if len(shape) == 1:
        do_coil_combine = False
        if args.verbose:
            print('   ----> NO.\n')
    else:
        do_coil_combine = True
        if args.verbose:
            print('  ----> YES.\n')

    # Do preproc
    if args.verbose:
            print('Begin proprocessing.... ')


    if do_coil_combine:
        if args.verbose:
            print('... Coil Combination ...')

        # Weights from reference data
        w = np.zeros((Reflist[0].shape[1]),dtype=np.complex128)
        for idx,r in enumerate(Reflist):
            Reflist[idx],wtmp = preproc.combine_FIDs(r,'svd_weights')
            w += wtmp
        w /= len(Reflist)

        for idx,fid in enumerate(FIDlist):
            if args.verbose:
                print('{}/{}'.format(idx,len(FIDlist)),end='\r')
            FIDlist[idx] = preproc.combine_FIDs(fid,'weighted',weights=w)
        
        if args.quant is not None:
            for idx,fid in enumerate(quantlist):
                quantlist[idx] = preproc.combine_FIDs(fid,'weighted',weights=w)
            
        if args.ecc is not None:
            for idx,fid in enumerate(ecclist):
                ecclist[idx] = preproc.combine_FIDs(fid,'weighted',weights=w)

    # Some useful quantitites from the headers
    bw = hdr['bandwidth']
    dt = hdr['dwelltime']
    cf = hdr['centralFrequency']*1E6

    # Save a copy of the combined data for the report output later
    FIDComblist = copy.deepcopy(FIDlist)

    # Bad average removal on the suppressed data
    if args.verbose:
        print(f'... Removing unlike averages (>1.96\u03C3 from mean) ...')
    FIDlist,_,keepIndicies,rmIndicies,_ = preproc.identifyUnlikeFIDs(FIDlist,bw,cf,sdlimit = 1.96,iterations=2,ppmlim=(0,4.2),shift=True)
    if args.verbose:
        print(f'{len(rmIndicies)}/{len(rmIndicies)+len(rmIndicies)} bad averages identified and removed.')
        print(f'The removed averages were {rmIndicies}.')

    # Frequency and phase align the FIDs
    if args.verbose:
        print('... Average FIDs ...')
    FIDlist,_,_ = preproc.phase_freq_align(FIDlist,bw,cf,ppmlim=(0,4.2),niter=2)
    Reflist,_,_ = preproc.phase_freq_align(Reflist,bw,cf,ppmlim=(0,4.2),niter=2)
    if args.quant is not None:
        quantlist,_,_ = preproc.phase_freq_align(quantlist,bw,cf,ppmlim=(0,4.2),niter=2)
    if args.ecc is not None:
        ecclist,_,_ = preproc.phase_freq_align(ecclist,bw,cf,ppmlim=(0,4.2),niter=2)
        
    # Average the data (if asked to do so - this might not be the case for FMRS)
    # Force everything to stay as a list so that data writing can be agnostic of 
    # averaging later on.
    if args.average:
        if args.verbose:
            print('... Average FIDs ...')
        FIDlist = [preproc.combine_FIDs(FIDlist,'mean')] 
        Reflist = [preproc.combine_FIDs(Reflist,'mean')]
        if args.quant is not None:
            quantlist = [preproc.combine_FIDs(quantlist,'mean')] 
    # Always average ecc if it exists as a separate scan        
    if args.ecc is not None:
        ecclist = [preproc.combine_FIDs(ecclist,'mean')]
    
    # Eddy current correction
    if args.ecc is not None:
        eccRef = ecclist[0]
    else:
        eccRef = preproc.combine_FIDs(Reflist,'mean') 
    iterFunction = lambda flist : [preproc.eddy_correct(fid,eccRef) for fid in flist]
    FIDlist = iterFunction(FIDlist)
    Reflist = iterFunction(Reflist)
    # Typically if a separate "quantification" water reference has been collected
    # it will have most gradients removed (OVS and water suppression), therefore
    # apply ecc using it's phase as a phase reference
    if args.quant is not None:
        quantlist = [preproc.eddy_correct(fid,quantlist[0]) for fid in quantlist]

    # HLSVD
    if args.hlsvd:
        hlsvdlimits = [-0.15,0.15]
        FIDlist = [preproc.hlsvd(fid,dt,cf,hlsvdlimits) for fid in FIDlist]
    
    if args.leftshift:
        iterFunction = lambda flist : [preproc.truncate(fid,args.leftshift,first_or_last='first') for fid in flist]
        FIDlist = iterFunction(FIDlist)
        Reflist = iterFunction(Reflist)
        if args.quant is not None:
            quantlist = iterFunction(quantlist)
        FIDComblist = iterFunction(FIDComblist)

    # Apply phasing based on a single peak (Cr)
    iterFunction = lambda flist,ppm : [preproc.phaseCorrect(fid,bw,cf,ppmlim=ppm)[0] for fid in flist]
    FIDlist = iterFunction(FIDlist,(2.8,3.2))
    Reflist = iterFunction(Reflist,(4.6,4.7))
    if args.quant is not None:
        quantlist = iterFunction(quantlist,(4.6,4.7))
    FIDComblist = iterFunction(FIDComblist,(2.8,3.2))

    # Save the data
    saveData(FIDlist,hdr,args.output,'metab',datatype=datatype)
    if  args.quant is not None:
        saveData(quantlist,hdr,args.output,'wref',datatype=datatype)
    else:
        saveData(FIDlist,hdr,args.output,'wref',datatype=datatype)
    
    # Produce html report
    if args.verbose:
        print('Create report')
    if args.t1 is not None:
        if datatype == 'NIFTI':
            fig = plotting.plot_world_orient(args.t1,args.data[0])
            fig.savefig(os.path.join(args.output,'voxel_location.png'))

         
    fig = plotting.plot_spectra(FIDlist=FIDComblist,
                                bandwidth=bw,
                                centralFrequency=cf,
                                ppmlim=(.2,4.2),
                                single_FID=FIDlist[0],plot_avg=True)
    fig.savefig(os.path.join(args.output,'coil_combined.png'))

    # Produce QC measures?


def readData(files,conjugate):
    FIDlist= []
    shape    = None
    datatype = None
    for filename in files:
        dtype      = mrs_io.check_datatype(filename)
        fid,header = mrs_io.read_FID(filename)
        fid        = np.squeeze(fid)
        if conjugate:
            fid = np.conj(fid)
        if shape is not None:
            if fid.shape != shape:
                raise(Exception('FIDs are incompatible in shapes'))
            if dtype != datatype:
                raise(Exception('FID files must all be of the same data type (e.g. RAW or NIFTI)'))
        else:
            shape    = fid.shape
            datatype = dtype
        
        FIDlist.append(fid)

    return FIDlist,header,shape,datatype
    
def saveData(FIDlist,hdr,outputDir,basename,datatype='NIFTI'):
    if len(FIDlist) == 1:
        nameGen = lambda x,y : os.path.join(outputDir,f'{basename}.{y}')
    else:
        nameGen = lambda x,y : os.path.join(outputDir,f'{basename}_{x:03.0f}.{y}')
    for iDx,f in enumerate(FIDlist):
        if datatype == 'RAW':            
            filename = nameGen(iDx,'RAW')
            mrs_io.lcm_io.saveRAW(filename,f,hdr)
        elif datatype == 'NIFTI':
            filename = nameGen(iDx,'nii')
            mrs_io.fsl_io.saveNIFTI(filename,f,hdr)
        
if __name__ == '__main__':
    main()
