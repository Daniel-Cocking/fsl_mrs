#!/usr/bin/env python

# fsl_mrs_sim - wrapper script for MRS spectra simulations
#
# Author: Saad Jbabdi <saad@fmrib.ox.ac.uk>
#         Largely based on Jamie Near's FID-A toolbox
#
# Copyright (C) 2019 University of Oxford 
# SHBASECOPYRIGHT

# Quick imports
import argparse
from fsl_mrs import __version__
from fsl_mrs.utils.splash import splash

def main():

    p = argparse.ArgumentParser(description='FSL Magnetic Resonance Spectroscopy Tools')
    p.add_argument('-v','--version', action='version', version=__version__)
    
    required     = p.add_argument_group('required arguments')
    mutual       = required.add_mutually_exclusive_group(required=True)
    optional     = p.add_argument_group('optional arguments')

    # positional REQUIRED ARGUMENTS
    p.add_argument('seqFile',type=str,metavar='SEQUENCE',
                          help='pulse sequence file or previous results file')

    # Mutual required arguments
    mutual.add_argument('-m','--metab',type=str, metavar='METAB',
                          help='Single metabolite string')

    mutual.add_argument('-b','--batch',type=str, metavar='METAB_FILE',
                          help='Batch simulate metabolites. Path to file containing metabolite list.')

    mutual.add_argument('-s','--spinsys',type=str, metavar='spinsysJSON',
                          help='Pass custom spin systems defined in json.')
    
    # OPTIONAL ARGUMENTS
    optional.add_argument('-o','--output',default='.',
                          required=False,type=str,metavar='<str>',
                          help='output folder')
    
    # optional.add_argument('--verbose',action="store_true",
    #                help='spit out verbose info')
    optional.add_argument('--overwrite',action="store_true",
                   help='overwrite existing output folder')
    optional.add_argument('--verbose',action="store_true",
                   help='Verbose output')

    
    # Parse command-line arguments
    args = p.parse_args()

    # Output kickass splash screen
    if args.verbose:
        splash(logo='mrs')

    
    # ######################################################
    # DO THE IMPORTS AFTER PARSING TO SPEED UP HELP DISPLAY    
    import os,sys,shutil,datetime,json,copy
    import numpy as np
    from fsl_mrs.denmatsim import simseq as sim
    from fsl_mrs.denmatsim import utils as simutils
    #from fsl_mrs.utils import mrs_io
    # ######################################################

    
    # Check if output folder exists
    overwrite = args.overwrite
    if args.output != '.':
        if os.path.exists(args.output):
            if not overwrite:
                print("Folder '{}' exists. Are you sure you want to delete it? [Y,N]".format(args.output))
                response = input()
                overwrite = response.upper() == "Y"
            if not overwrite:
                print('Early stopping...')
                exit()
            else:
                shutil.rmtree(args.output)
                os.mkdir(args.output)
        else:
            os.mkdir(args.output)


    #######  Do the work #######

    # Load the sequence file
    with open(args.seqFile,'r') as seqFile:
        # If exisitng results file then extract the relavent dict
        # Identify if file has a seq field
        jsonString = seqFile.read()
        seqFileParams = json.loads(jsonString)
        if 'seq' in seqFileParams:
            seqParams = seqFileParams['seq']
        else: #Â Assume that this is a plain sequence file and contains just the information we need
            seqParams = seqFileParams

    

    # Identify spin systems to run
    if args.spinsys is not None: # Parse the file containing a spin system description
        with open(args.spinsys,'r') as spinFile:
            jsonString = spinFile.read()
            spinsysIn = json.loads(jsonString)
            if 'shifts' in spinsysIn: # assume single spin system
                spinsys = [spinsysIn,]
                basename = os.path.basename(args.spinsys)
                prefix, suffix = os.path.splitext(basename)
                spinsToSim = [prefix,]
            else: # Assume multiple systems and create a list
                spinsys = []
                spinsToSim = []
                for systems in spinsysIn:
                    spinsys.append(spinsysIn[systems])
                    spinsToSim.append(systems)

    else:
        # Read built in spin system file
        spinSystems = simutils.readBuiltInSpins()

        if args.batch is not None: 
            # Parse file containing list of the known metabolites. Extract these from that list
            if os.path.isfile(args.batch):
                with open(args.batch,'r') as batchFile:
                    metabsRequested = batchFile.readlines()
                    metabsRequested = [l.rstrip() for l in metabsRequested if l!='\n']
            else:
                raise ValueError('batch argument expects a file name.')

        elif args.metab is not None: # Parse sting of metabolites that (hopefully) match known metabolites
            metabsRequested = args.metab.split(',')
        else:
            raise ValueError('Unknown spin system imput.')

        spinsys = []
        spinsToSim = []
        for metab in metabsRequested:
            sysmetab = 'sys'+metab
            if sysmetab in spinSystems:
                spinsys.append(spinSystems[sysmetab])
                spinsToSim.append(metab)
            else:
                print(f'{metab}({sysmetab}) not recognised.')
        print(f'Identified spinsystems: {spinsToSim}')

    
    # Loop over the spin systems (list)
    for iDx,(s,name) in enumerate(zip(spinsys,spinsToSim)):
        print(f'Running simulation on {name} ({iDx+1}/{len(spinsToSim)}).')
        sToSave = copy.deepcopy(s) # Make a copy here as some bits of s are converted to np.arrays inside simulator.
        # Run simulation
        densityMatriciesRe = []
        densityMatriciesIm = []
        if isinstance(s,list):
            combinedScaledFID = []            
            for ss in s:
                FID,ax,pmat = sim.simseq(ss,seqParams)
                combinedScaledFID.append(FID*ss['scaleFactor'])
                densityMatriciesRe.append(np.real(pmat).tolist())
                densityMatriciesIm.append(np.imag(pmat).tolist())
            combinedScaledFID = np.sum(combinedScaledFID,axis=0)

        else:    
            FID,ax,pmat = sim.simseq(s,seqParams)
            combinedScaledFID = FID*s['scaleFactor']
            densityMatriciesRe.append(np.real(pmat).tolist())
            densityMatriciesIm.append(np.imag(pmat).tolist())

        # Form results dictionary
        outputDict = {}
        outputDict.update({'seq':seqParams})
        basisDict = {}
        basisDict.update({'basis_re':np.real(combinedScaledFID).tolist()})
        basisDict.update({'basis_im':np.imag(combinedScaledFID).tolist()})
        basisDict.update({'basis_dwell':1/seqParams['Rx_SW']})
        basisDict.update({'basis_centre':ax['centreFreq']})
        basisDict.update({'basis_width':seqParams['Rx_LW']})
        basisDict.update({'basis_name':name})
        outputDict.update({'basis':basisDict}) 
        outputDict.update({'spinSys':sToSave})
        densmatdict = {'re':densityMatriciesRe,'im':densityMatriciesIm}
        outputDict.update({'outputDensityMatrix':densmatdict})
        metaDict = {'time':datetime.datetime.now().strftime("%Y%m%d_%H%M%S"),'SimVersion':''}
        outputDict.update({'meta':metaDict})        
        # Save to json file.
        fileOut = os.path.join(args.output,name+'.json')
        with open(fileOut, 'w', encoding='utf-8') as f:
            json.dump(outputDict, f, ensure_ascii=False, indent='\t')
        
    

if __name__ == '__main__':
    main()
